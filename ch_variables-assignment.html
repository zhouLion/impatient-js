
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <link rel="stylesheet" href="book.css" type="text/css">
    </head>
    <body>
    

        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              <script async="" type="text/javascript" src="https://cdn.carbonads.com/carbon.js?serve=CKYIEKQL&amp;placement=exploringjscom" id="_carbonads_js"></script>
          </div>
    
    <h2 id="ch_variables-assignment">11 Variables and assignment</h2>
<hr>
<div class="chapter-toc">
<ul>
<li>11.1 <a href="ch_variables-assignment.html#let"><code>let</code></a></li>
<li>11.2 <a href="ch_variables-assignment.html#const"><code>const</code></a>
<ul>
<li>11.2.1 <a href="ch_variables-assignment.html#const-and-immutability"><code>const</code> and immutability</a></li>
<li>11.2.2 <a href="ch_variables-assignment.html#const-and-loops"><code>const</code> and loops</a></li>
</ul></li>
<li>11.3 <a href="ch_variables-assignment.html#deciding-between-const-and-let">Deciding between <code>const</code> and <code>let</code></a></li>
<li>11.4 <a href="ch_variables-assignment.html#the-scope-of-a-variable">The scope of a variable</a>
<ul>
<li>11.4.1 <a href="ch_variables-assignment.html#shadowing-variables">Shadowing variables</a></li>
</ul></li>
<li>11.5 <a href="ch_variables-assignment.html#advanced-1">(Advanced)</a></li>
<li>11.6 <a href="ch_variables-assignment.html#terminology-static-vs.-dynamic">Terminology: static vs.&nbsp;dynamic</a>
<ul>
<li>11.6.1 <a href="ch_variables-assignment.html#static-phenomenon-scopes-of-variables">Static phenomenon: scopes of variables</a></li>
<li>11.6.2 <a href="ch_variables-assignment.html#dynamic-phenomenon-function-calls">Dynamic phenomenon: function calls</a></li>
</ul></li>
<li>11.7 <a href="ch_variables-assignment.html#global-variables-and-the-global-object">Global variables and the global object</a>
<ul>
<li>11.7.1 <a href="ch_variables-assignment.html#globalThis"><code>globalThis</code> [ES2020]</a></li>
</ul></li>
<li>11.8 <a href="ch_variables-assignment.html#declarations-scope-activation">Declarations: scope and activation</a>
<ul>
<li>11.8.1 <a href="ch_variables-assignment.html#const-and-let-temporal-dead-zone"><code>const</code> and <code>let</code>: temporal dead zone</a></li>
<li>11.8.2 <a href="ch_variables-assignment.html#function-declarations-and-early-activation">Function declarations and early activation</a></li>
<li>11.8.3 <a href="ch_variables-assignment.html#class-declarations-are-not-activated-early">Class declarations are not activated early</a></li>
<li>11.8.4 <a href="ch_variables-assignment.html#var-hoisting-partial-early-activation"><code>var</code>: hoisting (partial early activation)</a></li>
</ul></li>
<li>11.9 <a href="ch_variables-assignment.html#closures">Closures</a>
<ul>
<li>11.9.1 <a href="ch_variables-assignment.html#bound-variables-vs.-free-variables">Bound variables vs.&nbsp;free variables</a></li>
<li>11.9.2 <a href="ch_variables-assignment.html#what-is-a-closure">What is a closure?</a></li>
<li>11.9.3 <a href="ch_variables-assignment.html#example-a-factory-for-incrementors">Example: A factory for incrementors</a></li>
<li>11.9.4 <a href="ch_variables-assignment.html#use-cases-for-closures">Use cases for closures</a></li>
</ul></li>
</ul>
</div>
<hr>
<p>These are JavaScript’s main ways of declaring variables:</p>
<ul>
<li><code>let</code> declares mutable variables.</li>
<li><code>const</code> declares <em>constants</em> (immutable variables). <a id="index-entry-44" class="index-entry"></a></li>
</ul>
<p>Before ES6, there was also <code>var</code>. But it has several quirks, so it’s best to avoid it in modern JavaScript. You can read more about it in <a href="http://speakingjs.com/es5/ch16.html"><em>Speaking JavaScript</em></a>.</p>
<h3 id="let">11.1 <code>let</code></h3>
<p><a id="index-entry-45" class="index-entry"></a></p>
<p>Variables declared via <code>let</code> are mutable:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb107-1"><a href="ch_variables-assignment.html#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i<span class="op">;</span></span>
<span id="cb107-2"><a href="ch_variables-assignment.html#cb107-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb107-3"><a href="ch_variables-assignment.html#cb107-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb107-4"><a href="ch_variables-assignment.html#cb107-4" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(i<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<p>You can also declare and assign at the same time:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb108-1"><a href="ch_variables-assignment.html#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<h3 id="const">11.2 <code>const</code></h3>
<p><a id="index-entry-46" class="index-entry"></a></p>
<p>Variables declared via <code>const</code> are immutable. You must always initialize immediately:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb109-1"><a href="ch_variables-assignment.html#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// must initialize</span></span>
<span id="cb109-2"><a href="ch_variables-assignment.html#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="ch_variables-assignment.html#cb109-3" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb109-4"><a href="ch_variables-assignment.html#cb109-4" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> { i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span> }<span class="op">,</span></span>
<span id="cb109-5"><a href="ch_variables-assignment.html#cb109-5" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb109-6"><a href="ch_variables-assignment.html#cb109-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">'TypeError'</span><span class="op">,</span></span>
<span id="cb109-7"><a href="ch_variables-assignment.html#cb109-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">message</span><span class="op">:</span> <span class="st">'Assignment to constant variable.'</span><span class="op">,</span></span>
<span id="cb109-8"><a href="ch_variables-assignment.html#cb109-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb109-9"><a href="ch_variables-assignment.html#cb109-9" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<h4 id="const-and-immutability">11.2.1 <code>const</code> and immutability</h4>
<p><a id="index-entry-47" class="index-entry"></a></p>
<p>In JavaScript, <code>const</code> only means that the <em>binding</em> (the association between variable name and variable value) is immutable. The value itself may be mutable, like <code>obj</code> in the following example.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb110-1"><a href="ch_variables-assignment.html#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> obj <span class="op">=</span> { <span class="dt">prop</span><span class="op">:</span> <span class="dv">0</span> }<span class="op">;</span></span>
<span id="cb110-2"><a href="ch_variables-assignment.html#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="ch_variables-assignment.html#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Allowed: changing properties of `obj`</span></span>
<span id="cb110-4"><a href="ch_variables-assignment.html#cb110-4" aria-hidden="true" tabindex="-1"></a>obj<span class="op">.</span><span class="at">prop</span> <span class="op">=</span> obj<span class="op">.</span><span class="at">prop</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb110-5"><a href="ch_variables-assignment.html#cb110-5" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(obj<span class="op">.</span><span class="at">prop</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb110-6"><a href="ch_variables-assignment.html#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="ch_variables-assignment.html#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Not allowed: assigning to `obj`</span></span>
<span id="cb110-8"><a href="ch_variables-assignment.html#cb110-8" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb110-9"><a href="ch_variables-assignment.html#cb110-9" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> { obj <span class="op">=</span> {} }<span class="op">,</span></span>
<span id="cb110-10"><a href="ch_variables-assignment.html#cb110-10" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb110-11"><a href="ch_variables-assignment.html#cb110-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">'TypeError'</span><span class="op">,</span></span>
<span id="cb110-12"><a href="ch_variables-assignment.html#cb110-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">message</span><span class="op">:</span> <span class="st">'Assignment to constant variable.'</span><span class="op">,</span></span>
<span id="cb110-13"><a href="ch_variables-assignment.html#cb110-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb110-14"><a href="ch_variables-assignment.html#cb110-14" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<h4 id="const-and-loops">11.2.2 <code>const</code> and loops</h4>
<p>You can use <code>const</code> with <code>for-of</code> loops, where a fresh binding is created for each iteration:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb111-1"><a href="ch_variables-assignment.html#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">'hello'</span><span class="op">,</span> <span class="st">'world'</span>]<span class="op">;</span></span>
<span id="cb111-2"><a href="ch_variables-assignment.html#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">const</span> elem <span class="kw">of</span> arr) {</span>
<span id="cb111-3"><a href="ch_variables-assignment.html#cb111-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(elem)<span class="op">;</span></span>
<span id="cb111-4"><a href="ch_variables-assignment.html#cb111-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb111-5"><a href="ch_variables-assignment.html#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Output:</span></span>
<span id="cb111-6"><a href="ch_variables-assignment.html#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 'hello'</span></span>
<span id="cb111-7"><a href="ch_variables-assignment.html#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 'world'</span></span></code></pre></div>
<p>In plain <code>for</code> loops, you must use <code>let</code>, however:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb112-1"><a href="ch_variables-assignment.html#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> arr <span class="op">=</span> [<span class="st">'hello'</span><span class="op">,</span> <span class="st">'world'</span>]<span class="op">;</span></span>
<span id="cb112-2"><a href="ch_variables-assignment.html#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>arr<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb112-3"><a href="ch_variables-assignment.html#cb112-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> elem <span class="op">=</span> arr[i]<span class="op">;</span></span>
<span id="cb112-4"><a href="ch_variables-assignment.html#cb112-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(elem)<span class="op">;</span></span>
<span id="cb112-5"><a href="ch_variables-assignment.html#cb112-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="deciding-between-const-and-let">11.3 Deciding between <code>const</code> and <code>let</code></h3>
<p>I recommend the following rules to decide between <code>const</code> and <code>let</code>:</p>
<ul>
<li><code>const</code> indicates an immutable binding and that a variable never changes its value. Prefer it.</li>
<li><code>let</code> indicates that the value of a variable changes. Use it only when you can’t use <code>const</code>.</li>
</ul>
<div class="notebox">
<p><img src="img-book/img/icons/puzzle-piece-regular.svg" height="24">&nbsp; <strong>Exercise: <code>const</code></strong></p>
<p><code>exercises/variables-assignment/const_exrc.mjs</code></p>
</div>
<h3 id="the-scope-of-a-variable">11.4 The scope of a variable</h3>
<p><a id="index-entry-48" class="index-entry"></a><a id="index-entry-49" class="index-entry"></a></p>
<p>The <em>scope</em> of a variable is the region of a program where it can be accessed. Consider the following code.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb113-1"><a href="ch_variables-assignment.html#cb113-1" aria-hidden="true" tabindex="-1"></a>{ <span class="co">// // Scope A. Accessible: x</span></span>
<span id="cb113-2"><a href="ch_variables-assignment.html#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb113-3"><a href="ch_variables-assignment.html#cb113-3" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb113-4"><a href="ch_variables-assignment.html#cb113-4" aria-hidden="true" tabindex="-1"></a>  { <span class="co">// Scope B. Accessible: x, y</span></span>
<span id="cb113-5"><a href="ch_variables-assignment.html#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb113-6"><a href="ch_variables-assignment.html#cb113-6" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb113-7"><a href="ch_variables-assignment.html#cb113-7" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(y<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb113-8"><a href="ch_variables-assignment.html#cb113-8" aria-hidden="true" tabindex="-1"></a>    { <span class="co">// Scope C. Accessible: x, y, z</span></span>
<span id="cb113-9"><a href="ch_variables-assignment.html#cb113-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> z <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb113-10"><a href="ch_variables-assignment.html#cb113-10" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb113-11"><a href="ch_variables-assignment.html#cb113-11" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">.</span><span class="fu">equal</span>(y<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb113-12"><a href="ch_variables-assignment.html#cb113-12" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">.</span><span class="fu">equal</span>(z<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb113-13"><a href="ch_variables-assignment.html#cb113-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb113-14"><a href="ch_variables-assignment.html#cb113-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb113-15"><a href="ch_variables-assignment.html#cb113-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb113-16"><a href="ch_variables-assignment.html#cb113-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Outside. Not accessible: x, y, z</span></span>
<span id="cb113-17"><a href="ch_variables-assignment.html#cb113-17" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb113-18"><a href="ch_variables-assignment.html#cb113-18" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">,</span></span>
<span id="cb113-19"><a href="ch_variables-assignment.html#cb113-19" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb113-20"><a href="ch_variables-assignment.html#cb113-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">'ReferenceError'</span><span class="op">,</span></span>
<span id="cb113-21"><a href="ch_variables-assignment.html#cb113-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">message</span><span class="op">:</span> <span class="st">'x is not defined'</span><span class="op">,</span></span>
<span id="cb113-22"><a href="ch_variables-assignment.html#cb113-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb113-23"><a href="ch_variables-assignment.html#cb113-23" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<ul>
<li>Scope A is the <em>(direct) scope</em> of <code>x</code>.</li>
<li>Scopes B and C are <em>inner scopes</em> of scope A.</li>
<li>Scope A is an <em>outer scope</em> of scope B and scope C.</li>
</ul>
<p>Each variable is accessible in its direct scope and all scopes nested within that scope.</p>
<p>The variables declared via <code>const</code> and <code>let</code> are called <em>block-scoped</em> because their scopes are always the innermost surrounding blocks.</p>
<h4 id="shadowing-variables">11.4.1 Shadowing variables</h4>
<p>You can’t declare the same variable twice at the same level:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb114-1"><a href="ch_variables-assignment.html#cb114-1" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb114-2"><a href="ch_variables-assignment.html#cb114-2" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> {</span>
<span id="cb114-3"><a href="ch_variables-assignment.html#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">eval</span>(<span class="st">'let x = 1; let x = 2;'</span>)<span class="op">;</span></span>
<span id="cb114-4"><a href="ch_variables-assignment.html#cb114-4" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb114-5"><a href="ch_variables-assignment.html#cb114-5" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb114-6"><a href="ch_variables-assignment.html#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">'SyntaxError'</span><span class="op">,</span></span>
<span id="cb114-7"><a href="ch_variables-assignment.html#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">message</span><span class="op">:</span> <span class="st">"Identifier 'x' has already been declared"</span><span class="op">,</span></span>
<span id="cb114-8"><a href="ch_variables-assignment.html#cb114-8" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<div class="notebox">
<p><img src="img-book/img/icons/cogs-regular.svg" height="24">&nbsp; <strong>Why <code>eval()</code>?</strong></p>
<p><a href="ch_dynamic-code-evaluation.html#eval"><code>eval()</code></a> delays parsing (and therefore the <code>SyntaxError</code>), until the callback of <code>assert.throws()</code> is executed. If we didn’t use it, we’d already get an error when this code is parsed and <code>assert.throws()</code> wouldn’t even be executed.</p>
</div>
<p>You can, however, nest a block and use the same variable name <code>x</code> that you used outside the block:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb115-1"><a href="ch_variables-assignment.html#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb115-2"><a href="ch_variables-assignment.html#cb115-2" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb115-3"><a href="ch_variables-assignment.html#cb115-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb115-4"><a href="ch_variables-assignment.html#cb115-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb115-5"><a href="ch_variables-assignment.html#cb115-5" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb115-6"><a href="ch_variables-assignment.html#cb115-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb115-7"><a href="ch_variables-assignment.html#cb115-7" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<p><a id="index-entry-50" class="index-entry"></a></p>
<p>Inside the block, the inner <code>x</code> is the only accessible variable with that name. The inner <code>x</code> is said to <em>shadow</em> the outer <code>x</code>. Once you leave the block, you can access the old value again.</p>
<div class="notebox">
<p><img src="img-book/img/icons/list-regular.svg" height="24">&nbsp; <strong>Quiz: basic</strong></p>
<p>See <a href="ch_quizzes-exercises.html#quizzes">quiz app</a>.</p>
</div>
<h3 id="advanced-1">11.5 (Advanced)</h3>
<p>All remaining sections are advanced.</p>
<h3 id="terminology-static-vs.-dynamic">11.6 Terminology: static vs.&nbsp;dynamic</h3>
<p><a id="index-entry-51" class="index-entry"></a><a id="index-entry-52" class="index-entry"></a></p>
<p>These two adjectives describe phenomena in programming languages:</p>
<ul>
<li><em>Static</em> means that something is related to source code and can be determined without executing code.</li>
<li><em>Dynamic</em> means at runtime.</li>
</ul>
<p>Let’s look at examples for these two terms.</p>
<h4 id="static-phenomenon-scopes-of-variables">11.6.1 Static phenomenon: scopes of variables</h4>
<p>Variable scopes are a static phenomenon. Consider the following code:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb116-1"><a href="ch_variables-assignment.html#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f</span>() {</span>
<span id="cb116-2"><a href="ch_variables-assignment.html#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb116-3"><a href="ch_variables-assignment.html#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ···</span></span>
<span id="cb116-4"><a href="ch_variables-assignment.html#cb116-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><code>x</code> is <em>statically</em> (or <em>lexically</em>) <em>scoped</em>. That is, its scope is fixed and doesn’t change at runtime.</p>
<p>Variable scopes form a static tree (via static nesting).</p>
<h4 id="dynamic-phenomenon-function-calls">11.6.2 Dynamic phenomenon: function calls</h4>
<p>Function calls are a dynamic phenomenon. Consider the following code:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb117-1"><a href="ch_variables-assignment.html#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">g</span>(x) {}</span>
<span id="cb117-2"><a href="ch_variables-assignment.html#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">h</span>(y) {</span>
<span id="cb117-3"><a href="ch_variables-assignment.html#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">Math</span><span class="op">.</span><span class="fu">random</span>()) <span class="fu">g</span>(y)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb117-4"><a href="ch_variables-assignment.html#cb117-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Whether or not the function call in line A happens, can only be decided at runtime.</p>
<p>Function calls form a dynamic tree (via dynamic calls).</p>
<h3 id="global-variables-and-the-global-object">11.7 Global variables and the global object</h3>
<p><a id="index-entry-53" class="index-entry"></a> <a id="index-entry-54" class="index-entry"></a> <a id="index-entry-55" class="index-entry"></a></p>
<p>JavaScript’s variable scopes are nested. They form a tree:</p>
<ul>
<li>The outermost scope is the root of the tree.</li>
<li>The scopes directly contained in that scope are the children of the root.</li>
<li>And so on.</li>
</ul>
<p>The root is also called the <em>global scope</em>. In web browsers, the only location where one is directly in that scope is at the top level of a script. The variables of the global scope are called <em>global variables</em> and accessible everywhere. There are two kinds of global variables:</p>
<ul>
<li><em>Global declarative variables</em> are normal variables.
<ul>
<li>They can only be created while at the top level of a script, via <code>const</code>, <code>let</code>, and class declarations.</li>
</ul></li>
<li><em>Global object variables</em> are stored in properties of the so-called <em>global object</em>.
<ul>
<li>They are created in the top level of a script, via <code>var</code> and function declarations.</li>
<li>The global object can be accessed via the global variable <code>globalThis</code>. It can be used to create, read, and delete global object variables.</li>
<li>Other than that, global object variables work like normal variables.</li>
</ul></li>
</ul>
<p>The following HTML fragment demonstrates <code>globalThis</code> and the two kinds of global variables.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb118-1"><a href="ch_variables-assignment.html#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;script&gt;</span></span>
<span id="cb118-2"><a href="ch_variables-assignment.html#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> declarativeVariable <span class="op">=</span> <span class="st">'d'</span><span class="op">;</span></span>
<span id="cb118-3"><a href="ch_variables-assignment.html#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> objectVariable <span class="op">=</span> <span class="st">'o'</span><span class="op">;</span></span>
<span id="cb118-4"><a href="ch_variables-assignment.html#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/script&gt;</span></span>
<span id="cb118-5"><a href="ch_variables-assignment.html#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;script&gt;</span></span>
<span id="cb118-6"><a href="ch_variables-assignment.html#cb118-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// All scripts share the same top-level scope:</span></span>
<span id="cb118-7"><a href="ch_variables-assignment.html#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(declarativeVariable)<span class="op">;</span> <span class="co">// 'd'</span></span>
<span id="cb118-8"><a href="ch_variables-assignment.html#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(objectVariable)<span class="op">;</span> <span class="co">// 'o'</span></span>
<span id="cb118-9"><a href="ch_variables-assignment.html#cb118-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb118-10"><a href="ch_variables-assignment.html#cb118-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Not all declarations create properties of the global object:</span></span>
<span id="cb118-11"><a href="ch_variables-assignment.html#cb118-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(globalThis<span class="op">.</span><span class="at">declarativeVariable</span>)<span class="op">;</span> <span class="co">// undefined</span></span>
<span id="cb118-12"><a href="ch_variables-assignment.html#cb118-12" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(globalThis<span class="op">.</span><span class="at">objectVariable</span>)<span class="op">;</span> <span class="co">// 'o'</span></span>
<span id="cb118-13"><a href="ch_variables-assignment.html#cb118-13" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/script&gt;</span></span></code></pre></div>
<p>Each ECMAScript module has its own scope. Therefore, variables that exist at the top level of a module are not global. Fig.&nbsp;<a href="#fig:global-scope">5</a> illustrates how the various scopes are related.</p>
<figure>
<img src="img-book/5e2d628cb1d4eb4e246e3041142072031557d890.svg" id="fig:global-scope" width="415" height="233" alt="Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds of variables: object variables (managed via the global object) and normal declarative variables. Each ECMAScript module has its own scope which is contained in the global scope."><figcaption aria-hidden="true">Figure 5: The global scope is JavaScript’s outermost scope. It has two kinds of variables: <em>object variables</em> (managed via the <em>global object</em>) and normal <em>declarative variables</em>. Each ECMAScript module has its own scope which is contained in the global scope.</figcaption>
</figure>
<h4 id="globalThis">11.7.1 <code>globalThis</code> [ES2020]</h4>
<p><a id="index-entry-56" class="index-entry"></a></p>
<p>The global variable <code>globalThis</code> is the new standard way of accessing the global object. It got its name from the fact that it has the same value as <code>this</code> in global scope.</p>
<div class="notebox">
<p><img src="img-book/img/icons/cogs-regular.svg" height="24">&nbsp; <strong><code>globalThis</code> does not always directly point to the global object</strong></p>
<p>For example, in browsers, <a href="https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy">there is an indirection</a>. That indirection is normally not noticable, but it is there and can be observed.</p>
</div>
<h5 id="alternatives-to-globalthis">11.7.1.1 Alternatives to <code>globalThis</code></h5>
<p><a id="index-entry-57" class="index-entry"></a> <a id="index-entry-58" class="index-entry"></a> <a id="index-entry-59" class="index-entry"></a></p>
<p>Older ways of accessing the global object depend on the platform:</p>
<ul>
<li>Global variable <code>window</code>: is the classic way of referring to the global object. But it doesn’t work in Node.js and in Web Workers.</li>
<li>Global variable <code>self</code>: is available in Web Workers and browsers in general. But it isn’t supported by Node.js.</li>
<li>Global variable <code>global</code>: is only available in Node.js.</li>
</ul>
<h5 id="use-cases-for-globalthis">11.7.1.2 Use cases for <code>globalThis</code></h5>
<p>The global object is now considered a mistake that JavaScript can’t get rid of, due to backward compatibility. It affects performance negatively and is generally confusing.</p>
<p>ECMAScript 6 introduced several features that make it easier to avoid the global object – for example:</p>
<ul>
<li><code>const</code>, <code>let</code>, and class declarations don’t create global object properties when used in global scope.</li>
<li>Each ECMAScript module has its own local scope.</li>
</ul>
<p>It is usually better to access global object variables via variables and not via properties of <code>globalThis</code>. The former has always worked the same on all JavaScript platforms.</p>
<p>Tutorials on the web occasionally access global variables <code>globVar</code> via <code>window.globVar</code>. But the prefix “<code>window.</code>” is not necessary and I recommend to omit it:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb119-1"><a href="ch_variables-assignment.html#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="bu">window</span><span class="op">.</span><span class="fu">encodeURIComponent</span>(str)<span class="op">;</span> <span class="co">// no</span></span>
<span id="cb119-2"><a href="ch_variables-assignment.html#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="pp">encodeURIComponent</span>(str)<span class="op">;</span> <span class="co">// yes</span></span></code></pre></div>
<p>Therefore, there are relatively few use cases for <code>globalThis</code> – for example:</p>
<ul>
<li><a href="ch_modules.html#polyfills"><em>Polyfills</em></a> that add new features to old JavaScript engines.</li>
<li>Feature detection, to find out what features a JavaScript engine supports.</li>
</ul>
<h3 id="declarations-scope-activation">11.8 Declarations: scope and activation</h3>
<p>These are two key aspects of declarations:</p>
<ul>
<li>Scope: Where can a declared entity be seen? This is a static trait.</li>
<li>Activation: When can I access an entity? This is a dynamic trait. Some entities can be accessed as soon as we enter their scopes. For others, we have to wait until execution reaches their declarations.</li>
</ul>
<p>Tbl.&nbsp;<a href="#tbl:aspects-of-declarations">1</a> summarizes how various declarations handle these aspects.</p>
<div id="tbl:aspects-of-declarations">
<table>
<caption>Table 1: Aspects of declarations. “Duplicates” describes if a declaration can be used twice with the same name (per scope). “Global prop.” describes if a declaration adds a property to the global object, when it is executed in the global scope of a script. <em>TDZ</em> means <em>temporal dead zone</em> (which is explained later). (*) Function declarations are normally block-scoped, but function-scoped in <a href="ch_syntax.html#strict-mode">sloppy mode</a>.</caption>
<thead>
<tr class="header">
<th></th>
<th>Scope</th>
<th>Activation</th>
<th>Duplicates</th>
<th>Global prop.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>const</code></td>
<td>Block</td>
<td>decl. (TDZ)</td>
<td><code>✘</code></td>
<td><code>✘</code></td>
</tr>
<tr class="even">
<td><code>let</code></td>
<td>Block</td>
<td>decl. (TDZ)</td>
<td><code>✘</code></td>
<td><code>✘</code></td>
</tr>
<tr class="odd">
<td><code>function</code></td>
<td>Block (*)</td>
<td>start</td>
<td><code>✔</code></td>
<td><code>✔</code></td>
</tr>
<tr class="even">
<td><code>class</code></td>
<td>Block</td>
<td>decl. (TDZ)</td>
<td><code>✘</code></td>
<td><code>✘</code></td>
</tr>
<tr class="odd">
<td><code>import</code></td>
<td>Module</td>
<td>same as export</td>
<td><code>✘</code></td>
<td><code>✘</code></td>
</tr>
<tr class="even">
<td><code>var</code></td>
<td>Function</td>
<td>start, partially</td>
<td><code>✔</code></td>
<td><code>✔</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>import</code> is described in <a href="ch_modules.html#ecmascript-modules">§27.5 “ECMAScript modules”</a>. The following sections describe the other constructs in more detail.</p>
<h4 id="const-and-let-temporal-dead-zone">11.8.1 <code>const</code> and <code>let</code>: temporal dead zone</h4>
<p><a id="index-entry-60" class="index-entry"></a><a id="index-entry-61" class="index-entry"></a></p>
<p>For JavaScript, TC39 needed to decide what happens if you access a constant in its direct scope, before its declaration:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb120-1"><a href="ch_variables-assignment.html#cb120-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb120-2"><a href="ch_variables-assignment.html#cb120-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">;</span> <span class="co">// What happens here?</span></span>
<span id="cb120-3"><a href="ch_variables-assignment.html#cb120-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> x<span class="op">;</span></span>
<span id="cb120-4"><a href="ch_variables-assignment.html#cb120-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Some possible approaches are:</p>
<ol type="1">
<li>The name is resolved in the scope surrounding the current scope.</li>
<li>You get <code>undefined</code>.</li>
<li>There is an error.</li>
</ol>
<p>Approach 1 was rejected because there is no precedent in the language for this approach. It would therefore not be intuitive to JavaScript programmers.</p>
<p>Approach 2 was rejected because then <code>x</code> wouldn’t be a constant – it would have different values before and after its declaration.</p>
<p><code>let</code> uses the same approach 3 as <code>const</code>, so that both work similarly and it’s easy to switch between them.</p>
<p>The time between entering the scope of a variable and executing its declaration is called the <em>temporal dead zone</em> (TDZ) of that variable:</p>
<ul>
<li>During this time, the variable is considered to be uninitialized (as if that were a special value it has).</li>
<li>If you access an uninitialized variable, you get a <code>ReferenceError</code>.</li>
<li>Once you reach a variable declaration, the variable is set to either the value of the initializer (specified via the assignment symbol) or <code>undefined</code> – if there is no initializer.</li>
</ul>
<p>The following code illustrates the temporal dead zone:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb121-1"><a href="ch_variables-assignment.html#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="kw">true</span>) { <span class="co">// entering scope of `tmp`, TDZ starts</span></span>
<span id="cb121-2"><a href="ch_variables-assignment.html#cb121-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `tmp` is uninitialized:</span></span>
<span id="cb121-3"><a href="ch_variables-assignment.html#cb121-3" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">throws</span>(() <span class="kw">=&gt;</span> (tmp <span class="op">=</span> <span class="st">'abc'</span>)<span class="op">,</span> <span class="bu">ReferenceError</span>)<span class="op">;</span></span>
<span id="cb121-4"><a href="ch_variables-assignment.html#cb121-4" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">throws</span>(() <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(tmp)<span class="op">,</span> <span class="bu">ReferenceError</span>)<span class="op">;</span></span>
<span id="cb121-5"><a href="ch_variables-assignment.html#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="ch_variables-assignment.html#cb121-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tmp<span class="op">;</span> <span class="co">// TDZ ends</span></span>
<span id="cb121-7"><a href="ch_variables-assignment.html#cb121-7" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(tmp<span class="op">,</span> <span class="kw">undefined</span>)<span class="op">;</span></span>
<span id="cb121-8"><a href="ch_variables-assignment.html#cb121-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The next example shows that the temporal dead zone is truly <em>temporal</em> (related to time):</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb122-1"><a href="ch_variables-assignment.html#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="kw">true</span>) { <span class="co">// entering scope of `myVar`, TDZ starts</span></span>
<span id="cb122-2"><a href="ch_variables-assignment.html#cb122-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> func <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb122-3"><a href="ch_variables-assignment.html#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(myVar)<span class="op">;</span> <span class="co">// executed later</span></span>
<span id="cb122-4"><a href="ch_variables-assignment.html#cb122-4" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb122-5"><a href="ch_variables-assignment.html#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="ch_variables-assignment.html#cb122-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We are within the TDZ:</span></span>
<span id="cb122-7"><a href="ch_variables-assignment.html#cb122-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Accessing `myVar` causes `ReferenceError`</span></span>
<span id="cb122-8"><a href="ch_variables-assignment.html#cb122-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-9"><a href="ch_variables-assignment.html#cb122-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> myVar <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// TDZ ends</span></span>
<span id="cb122-10"><a href="ch_variables-assignment.html#cb122-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">func</span>()<span class="op">;</span> <span class="co">// OK, called outside TDZ</span></span>
<span id="cb122-11"><a href="ch_variables-assignment.html#cb122-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Even though <code>func()</code> is located before the declaration of <code>myVar</code> and uses that variable, we can call <code>func()</code>. But we have to wait until the temporal dead zone of <code>myVar</code> is over.</p>
<h4 id="function-declarations-and-early-activation">11.8.2 Function declarations and early activation</h4>
<p><a id="index-entry-62" class="index-entry"></a></p>
<div class="notebox">
<p><img src="img-book/img/icons/eye-regular.svg" height="24">&nbsp; <strong>More information on functions</strong></p>
<p>In this section, we are using functions – before we had a chance to learn them properly. Hopefully, everything still makes sense. Whenever it doesn’t, please see <a href="ch_callables.html">§25 “Callable values”</a>.</p>
</div>
<p>A function declaration is always executed when entering its scope, regardless of where it is located within that scope. That enables you to call a function <code>foo()</code> before it is declared:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb123-1"><a href="ch_variables-assignment.html#cb123-1" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">foo</span>()<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span> <span class="co">// OK</span></span>
<span id="cb123-2"><a href="ch_variables-assignment.html#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span>() { <span class="cf">return</span> <span class="dv">123</span><span class="op">;</span> }</span></code></pre></div>
<p>The early activation of <code>foo()</code> means that the previous code is equivalent to:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb124-1"><a href="ch_variables-assignment.html#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span>() { <span class="cf">return</span> <span class="dv">123</span><span class="op">;</span> }</span>
<span id="cb124-2"><a href="ch_variables-assignment.html#cb124-2" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">foo</span>()<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span></code></pre></div>
<p>If you declare a function via <code>const</code> or <code>let</code>, then it is not activated early. In the following example, you can only use <code>bar()</code> after its declaration.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb125-1"><a href="ch_variables-assignment.html#cb125-1" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb125-2"><a href="ch_variables-assignment.html#cb125-2" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> <span class="fu">bar</span>()<span class="op">,</span> <span class="co">// before declaration</span></span>
<span id="cb125-3"><a href="ch_variables-assignment.html#cb125-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">ReferenceError</span>)<span class="op">;</span></span>
<span id="cb125-4"><a href="ch_variables-assignment.html#cb125-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-5"><a href="ch_variables-assignment.html#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> bar <span class="op">=</span> () <span class="kw">=&gt;</span> { <span class="cf">return</span> <span class="dv">123</span><span class="op">;</span> }<span class="op">;</span></span>
<span id="cb125-6"><a href="ch_variables-assignment.html#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="ch_variables-assignment.html#cb125-7" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">bar</span>()<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span> <span class="co">// after declaration </span></span></code></pre></div>
<h5 id="calling-ahead-without-early-activation">11.8.2.1 Calling ahead without early activation</h5>
<p>Even if a function <code>g()</code> is not activated early, it can be called by a preceding function <code>f()</code> (in the same scope) if we adhere to the following rule: <code>f()</code> must be invoked after the declaration of <code>g()</code>.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb126-1"><a href="ch_variables-assignment.html#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> f <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="fu">g</span>()<span class="op">;</span></span>
<span id="cb126-2"><a href="ch_variables-assignment.html#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> g <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb126-3"><a href="ch_variables-assignment.html#cb126-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-4"><a href="ch_variables-assignment.html#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="co">// We call f() after g() was declared:</span></span>
<span id="cb126-5"><a href="ch_variables-assignment.html#cb126-5" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">f</span>()<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span></code></pre></div>
<p>The functions of a module are usually invoked after its complete body is executed. Therefore, in modules, you rarely need to worry about the order of functions.</p>
<p>Lastly, note how early activation automatically keeps the aforementioned rule: when entering a scope, all function declarations are executed first, before any calls are made.</p>
<h5 id="a-pitfall-of-early-activation">11.8.2.2 A pitfall of early activation</h5>
<p>If you rely on early activation to call a function before its declaration, then you need to be careful that it doesn’t access data that isn’t activated early.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb127-1"><a href="ch_variables-assignment.html#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="fu">funcDecl</span>()<span class="op">;</span></span>
<span id="cb127-2"><a href="ch_variables-assignment.html#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="ch_variables-assignment.html#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MY_STR <span class="op">=</span> <span class="st">'abc'</span><span class="op">;</span></span>
<span id="cb127-4"><a href="ch_variables-assignment.html#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">funcDecl</span>() {</span>
<span id="cb127-5"><a href="ch_variables-assignment.html#cb127-5" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb127-6"><a href="ch_variables-assignment.html#cb127-6" aria-hidden="true" tabindex="-1"></a>    () <span class="kw">=&gt;</span> MY_STR<span class="op">,</span></span>
<span id="cb127-7"><a href="ch_variables-assignment.html#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ReferenceError</span>)<span class="op">;</span></span>
<span id="cb127-8"><a href="ch_variables-assignment.html#cb127-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The problem goes away if you make the call to <code>funcDecl()</code> after the declaration of <code>MY_STR</code>.</p>
<h5 id="the-pros-and-cons-of-early-activation">11.8.2.3 The pros and cons of early activation</h5>
<p>We have seen that early activation has a pitfall and that you can get most of its benefits without using it. Therefore, it is better to avoid early activation. But I don’t feel strongly about this and, as mentioned before, often use function declarations because I like their syntax.</p>
<h4 id="class-declarations-are-not-activated-early">11.8.3 Class declarations are not activated early</h4>
<p>Even though they are similar to function declarations in some ways, <a href="ch_proto-chains-classes.html#classes">class declarations</a> are not activated early:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb128-1"><a href="ch_variables-assignment.html#cb128-1" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">throws</span>(</span>
<span id="cb128-2"><a href="ch_variables-assignment.html#cb128-2" aria-hidden="true" tabindex="-1"></a>  () <span class="kw">=&gt;</span> <span class="kw">new</span> <span class="fu">MyClass</span>()<span class="op">,</span></span>
<span id="cb128-3"><a href="ch_variables-assignment.html#cb128-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">ReferenceError</span>)<span class="op">;</span></span>
<span id="cb128-4"><a href="ch_variables-assignment.html#cb128-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-5"><a href="ch_variables-assignment.html#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass {}</span>
<span id="cb128-6"><a href="ch_variables-assignment.html#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="ch_variables-assignment.html#cb128-7" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="kw">new</span> <span class="fu">MyClass</span>() <span class="kw">instanceof</span> MyClass<span class="op">,</span> <span class="kw">true</span>)<span class="op">;</span></span></code></pre></div>
<p>Why is that? Consider the following class declaration:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb129-1"><a href="ch_variables-assignment.html#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass <span class="kw">extends</span> <span class="bu">Object</span> {}</span></code></pre></div>
<p>The operand of <code>extends</code> is an expression. Therefore, you can do things like this:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb130-1"><a href="ch_variables-assignment.html#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> identity <span class="op">=</span> x <span class="kw">=&gt;</span> x<span class="op">;</span></span>
<span id="cb130-2"><a href="ch_variables-assignment.html#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass <span class="kw">extends</span> <span class="fu">identity</span>(<span class="bu">Object</span>) {}</span></code></pre></div>
<p>Evaluating such an expression must be done at the location where it is mentioned. Anything else would be confusing. That explains why class declarations are not activated early.</p>
<h4 id="var-hoisting-partial-early-activation">11.8.4 <code>var</code>: hoisting (partial early activation)</h4>
<p><a id="index-entry-63" class="index-entry"></a></p>
<p><code>var</code> is an older way of declaring variables that predates <code>const</code> and <code>let</code> (which are preferred now). Consider the following <code>var</code> declaration.</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb131-1"><a href="ch_variables-assignment.html#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> x <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></span></code></pre></div>
<p>This declaration has two parts:</p>
<ul>
<li>Declaration <code>var x</code>: The scope of a <code>var</code>-declared variable is the innermost surrounding function and not the innermost surrounding block, as for most other declarations. Such a variable is already active at the beginning of its scope and initialized with <code>undefined</code>.</li>
<li>Assignment <code>x = 123</code>: The assignment is always executed in place.</li>
</ul>
<p>The following code demonstrates the effects of <code>var</code>:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb132-1"><a href="ch_variables-assignment.html#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">f</span>() {</span>
<span id="cb132-2"><a href="ch_variables-assignment.html#cb132-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Partial early activation:</span></span>
<span id="cb132-3"><a href="ch_variables-assignment.html#cb132-3" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="kw">undefined</span>)<span class="op">;</span></span>
<span id="cb132-4"><a href="ch_variables-assignment.html#cb132-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">true</span>) {</span>
<span id="cb132-5"><a href="ch_variables-assignment.html#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> x <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb132-6"><a href="ch_variables-assignment.html#cb132-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The assignment is executed in place:</span></span>
<span id="cb132-7"><a href="ch_variables-assignment.html#cb132-7" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span>
<span id="cb132-8"><a href="ch_variables-assignment.html#cb132-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb132-9"><a href="ch_variables-assignment.html#cb132-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Scope is function, not block:</span></span>
<span id="cb132-10"><a href="ch_variables-assignment.html#cb132-10" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(x<span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></span>
<span id="cb132-11"><a href="ch_variables-assignment.html#cb132-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="closures">11.9 Closures</h3>
<p><a id="index-entry-64" class="index-entry"></a></p>
<p>Before we can explore closures, we need to learn about bound variables and free variables.</p>
<h4 id="bound-variables-vs.-free-variables">11.9.1 Bound variables vs.&nbsp;free variables</h4>
<p><a id="index-entry-65" class="index-entry"></a><a id="index-entry-66" class="index-entry"></a> <a id="index-entry-67" class="index-entry"></a><a id="index-entry-68" class="index-entry"></a></p>
<p>Per scope, there is a set of variables that are mentioned. Among these variables we distinguish:</p>
<ul>
<li><em>Bound variables</em> are declared within the scope. They are parameters and local variables.</li>
<li><em>Free variables</em> are declared externally. They are also called <em>non-local variables</em>.</li>
</ul>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb133-1"><a href="ch_variables-assignment.html#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">func</span>(x) {</span>
<span id="cb133-2"><a href="ch_variables-assignment.html#cb133-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> y <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb133-3"><a href="ch_variables-assignment.html#cb133-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(z)<span class="op">;</span></span>
<span id="cb133-4"><a href="ch_variables-assignment.html#cb133-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In the body of <code>func()</code>, <code>x</code> and <code>y</code> are bound variables. <code>z</code> is a free variable.</p>
<h4 id="what-is-a-closure">11.9.2 What is a closure?</h4>
<p>What is a closure then?</p>
<blockquote>
<p>A <em>closure</em> is a function plus a connection to the variables that exist at its “birth place”.</p>
</blockquote>
<p>What is the point of keeping this connection? It provides the values for the free variables of the function – for example:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb134-1"><a href="ch_variables-assignment.html#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">funcFactory</span>(value) {</span>
<span id="cb134-2"><a href="ch_variables-assignment.html#cb134-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb134-3"><a href="ch_variables-assignment.html#cb134-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb134-4"><a href="ch_variables-assignment.html#cb134-4" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb134-5"><a href="ch_variables-assignment.html#cb134-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb134-6"><a href="ch_variables-assignment.html#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="ch_variables-assignment.html#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> func <span class="op">=</span> <span class="fu">funcFactory</span>(<span class="st">'abc'</span>)<span class="op">;</span></span>
<span id="cb134-8"><a href="ch_variables-assignment.html#cb134-8" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">func</span>()<span class="op">,</span> <span class="st">'abc'</span>)<span class="op">;</span> <span class="co">// (A)</span></span></code></pre></div>
<p><code>funcFactory</code> returns a closure that is assigned to <code>func</code>. Because <code>func</code> has the connection to the variables at its birth place, it can still access the free variable <code>value</code> when it is called in line A (even though it “escaped” its scope).</p>
<div class="notebox">
<p><img src="img-book/img/icons/lightbulb-regular.svg" height="24">&nbsp; <strong>All functions in JavaScript are closures</strong></p>
<p>Static scoping is supported via closures in JavaScript. Therefore, every function is a closure.</p>
</div>
<h4 id="example-a-factory-for-incrementors">11.9.3 Example: A factory for incrementors</h4>
<p>The following function returns <em>incrementors</em> (a name that I just made up). An incrementor is a function that internally stores a number. When it is called, it updates that number by adding the argument to it and returns the new value.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb135-1"><a href="ch_variables-assignment.html#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createInc</span>(startValue) {</span>
<span id="cb135-2"><a href="ch_variables-assignment.html#cb135-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (step) <span class="kw">=&gt;</span> { <span class="co">// (A)</span></span>
<span id="cb135-3"><a href="ch_variables-assignment.html#cb135-3" aria-hidden="true" tabindex="-1"></a>    startValue <span class="op">+=</span> step<span class="op">;</span></span>
<span id="cb135-4"><a href="ch_variables-assignment.html#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> startValue<span class="op">;</span></span>
<span id="cb135-5"><a href="ch_variables-assignment.html#cb135-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb135-6"><a href="ch_variables-assignment.html#cb135-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb135-7"><a href="ch_variables-assignment.html#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> inc <span class="op">=</span> <span class="fu">createInc</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb135-8"><a href="ch_variables-assignment.html#cb135-8" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">equal</span>(<span class="fu">inc</span>(<span class="dv">2</span>)<span class="op">,</span> <span class="dv">7</span>)<span class="op">;</span></span></code></pre></div>
<p>We can see that the function created in line A keeps its internal number in the free variable <code>startValue</code>. This time, we don’t just read from the birth scope, we use it to store data that we change and that persists across function calls.</p>
<p>We can create more storage slots in the birth scope, via local variables:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb136-1"><a href="ch_variables-assignment.html#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createInc</span>(startValue) {</span>
<span id="cb136-2"><a href="ch_variables-assignment.html#cb136-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> index <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb136-3"><a href="ch_variables-assignment.html#cb136-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (step) <span class="kw">=&gt;</span> {</span>
<span id="cb136-4"><a href="ch_variables-assignment.html#cb136-4" aria-hidden="true" tabindex="-1"></a>    startValue <span class="op">+=</span> step<span class="op">;</span></span>
<span id="cb136-5"><a href="ch_variables-assignment.html#cb136-5" aria-hidden="true" tabindex="-1"></a>    index<span class="op">++;</span></span>
<span id="cb136-6"><a href="ch_variables-assignment.html#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [index<span class="op">,</span> startValue]<span class="op">;</span></span>
<span id="cb136-7"><a href="ch_variables-assignment.html#cb136-7" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb136-8"><a href="ch_variables-assignment.html#cb136-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb136-9"><a href="ch_variables-assignment.html#cb136-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> inc <span class="op">=</span> <span class="fu">createInc</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb136-10"><a href="ch_variables-assignment.html#cb136-10" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">deepEqual</span>(<span class="fu">inc</span>(<span class="dv">2</span>)<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">7</span>])<span class="op">;</span></span>
<span id="cb136-11"><a href="ch_variables-assignment.html#cb136-11" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">deepEqual</span>(<span class="fu">inc</span>(<span class="dv">2</span>)<span class="op">,</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">9</span>])<span class="op">;</span></span>
<span id="cb136-12"><a href="ch_variables-assignment.html#cb136-12" aria-hidden="true" tabindex="-1"></a>assert<span class="op">.</span><span class="fu">deepEqual</span>(<span class="fu">inc</span>(<span class="dv">2</span>)<span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">11</span>])<span class="op">;</span></span></code></pre></div>
<h4 id="use-cases-for-closures">11.9.4 Use cases for closures</h4>
<p>What are closures good for?</p>
<ul>
<li><p>For starters, they are simply an implementation of static scoping. As such, they provide context data for callbacks.</p></li>
<li><p>They can also be used by functions to store state that persists across function calls. <code>createInc()</code> is an example of that.</p></li>
<li><p>And they can provide private data for objects (produced via literals or classes). The details of how that works are explained in <a href="https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments"><em>Exploring ES6</em></a>.</p></li>
</ul>
<div class="notebox">
<p><img src="img-book/img/icons/list-regular.svg" height="24">&nbsp; <strong>Quiz: advanced</strong></p>
<p>See <a href="ch_quizzes-exercises.html#quizzes">quiz app</a>.</p>
</div>

    <div class="footer">
      <div>
                <a id="commentLink" href="https://github.com/rauschma/impatient-js/issues/6">Comments</a>
        <script defer="" src="count-comments.js"></script>
              </div>
            <div>
        Next: <a href="ch_values.html">12 Values</a>
      </div>
          </div>
  
    </body>
    </html>
    