
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <link rel="stylesheet" href="book.css" type="text/css">
    </head>
    <body>
    

        <div id="adbox">
      <div id="adbox-explain">(Ad, please don’t block.)</div>
              <script async="" type="text/javascript" src="https://cdn.carbonads.com/carbon.js?serve=CKYIEKQL&amp;placement=exploringjscom" id="_carbonads_js"></script>
          </div>
    
    <h2 id="ch_async-js">39 Asynchronous programming in JavaScript</h2>
<p><a id="index-entry-447" class="index-entry"></a></p>
<hr>
<div class="chapter-toc">
<ul>
<li>39.1 <a href="ch_async-js.html#a-roadmap-for-asynchronous-programming-in-javascript">A roadmap for asynchronous programming in JavaScript</a>
<ul>
<li>39.1.1 <a href="ch_async-js.html#synchronous-functions">Synchronous functions</a></li>
<li>39.1.2 <a href="ch_async-js.html#javascript-executes-tasks-sequentially-in-a-single-process">JavaScript executes tasks sequentially in a single process</a></li>
<li>39.1.3 <a href="ch_async-js.html#roadmap-callbacks-for-async">Callback-based asynchronous functions</a></li>
<li>39.1.4 <a href="ch_async-js.html#promise-based-asynchronous-functions">Promise-based asynchronous functions</a></li>
<li>39.1.5 <a href="ch_async-js.html#roadmap-async-functions">Async functions</a></li>
<li>39.1.6 <a href="ch_async-js.html#next-steps">Next steps</a></li>
</ul></li>
<li>39.2 <a href="ch_async-js.html#the-call-stack">The call stack</a></li>
<li>39.3 <a href="ch_async-js.html#the-event-loop">The event loop</a></li>
<li>39.4 <a href="ch_async-js.html#how-to-avoid-blocking-the-javascript-process">How to avoid blocking the JavaScript process</a>
<ul>
<li>39.4.1 <a href="ch_async-js.html#blocking-browsers">The user interface of the browser can be blocked</a></li>
<li>39.4.2 <a href="ch_async-js.html#web-workers">How can we avoid blocking the browser?</a></li>
<li>39.4.3 <a href="ch_async-js.html#taking-breaks">Taking breaks</a></li>
<li>39.4.4 <a href="ch_async-js.html#run-to-completion-semantics">Run-to-completion semantics</a></li>
</ul></li>
<li>39.5 <a href="ch_async-js.html#patterns-for-delivering-asynchronous-results">Patterns for delivering asynchronous results</a>
<ul>
<li>39.5.1 <a href="ch_async-js.html#event-pattern">Delivering asynchronous results via events</a></li>
<li>39.5.2 <a href="ch_async-js.html#callback-pattern">Delivering asynchronous results via callbacks</a></li>
</ul></li>
<li>39.6 <a href="ch_async-js.html#asynchronous-code-the-downsides">Asynchronous code: the downsides</a></li>
<li>39.7 <a href="ch_async-js.html#resources">Resources</a></li>
</ul>
</div>
<hr>
<p>This chapter explains the foundations of asynchronous programming in JavaScript.</p>
<h3 id="a-roadmap-for-asynchronous-programming-in-javascript">39.1 A roadmap for asynchronous programming in JavaScript</h3>
<p>This section provides a roadmap for the content on asynchronous programming in JavaScript.</p>
<div class="notebox">
<p><img src="img-book/img/icons/eye-regular.svg" height="24">&nbsp; <strong>Don’t worry about the details!</strong></p>
<p>Don’t worry if you don’t understand everything yet. This is just a quick peek at what’s coming up.</p>
</div>
<h4 id="synchronous-functions">39.1.1 Synchronous functions</h4>
<p>Normal functions are <em>synchronous</em>: the caller waits until the callee is finished with its computation. <code>divideSync()</code> in line A is a synchronous function call:</p>
<div class="sourceCode" id="cb1109"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1109-1"><a href="ch_async-js.html#cb1109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb1109-2"><a href="ch_async-js.html#cb1109-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb1109-3"><a href="ch_async-js.html#cb1109-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> result <span class="op">=</span> <span class="fu">divideSync</span>(<span class="dv">12</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1109-4"><a href="ch_async-js.html#cb1109-4" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb1109-5"><a href="ch_async-js.html#cb1109-5" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (err) {</span>
<span id="cb1109-6"><a href="ch_async-js.html#cb1109-6" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">fail</span>(err)<span class="op">;</span></span>
<span id="cb1109-7"><a href="ch_async-js.html#cb1109-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1109-8"><a href="ch_async-js.html#cb1109-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h4 id="javascript-executes-tasks-sequentially-in-a-single-process">39.1.2 JavaScript executes tasks sequentially in a single process</h4>
<p>By default, JavaScript <em>tasks</em> are functions that are executed sequentially in a single process. That looks like this:</p>
<div class="sourceCode" id="cb1110"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1110-1"><a href="ch_async-js.html#cb1110-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb1110-2"><a href="ch_async-js.html#cb1110-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> task <span class="op">=</span> taskQueue<span class="op">.</span><span class="fu">dequeue</span>()<span class="op">;</span></span>
<span id="cb1110-3"><a href="ch_async-js.html#cb1110-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">task</span>()<span class="op">;</span> <span class="co">// run task</span></span>
<span id="cb1110-4"><a href="ch_async-js.html#cb1110-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This loop is also called the <em>event loop</em> because events, such as clicking a mouse, add tasks to the queue.</p>
<p>Due to this style of cooperative multitasking, we don’t want a task to block other tasks from being executed while, for example, it waits for results coming from a server. <span data-refcheck="#roadmap-callbacks-for-async">The next subsection</span> explores how to handle this case.</p>
<h4 id="roadmap-callbacks-for-async">39.1.3 Callback-based asynchronous functions</h4>
<p>What if <code>divide()</code> needs a server to compute its result? Then the result should be delivered in a different manner: The caller shouldn’t have to wait (synchronously) until the result is ready; it should be notified (asynchronously) when it is. One way of delivering the result asynchronously is by giving <code>divide()</code> a callback function that it uses to notify the caller.</p>
<div class="sourceCode" id="cb1111"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1111-1"><a href="ch_async-js.html#cb1111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb1111-2"><a href="ch_async-js.html#cb1111-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">divideCallback</span>(<span class="dv">12</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb1111-3"><a href="ch_async-js.html#cb1111-3" aria-hidden="true" tabindex="-1"></a>    (err<span class="op">,</span> result) <span class="kw">=&gt;</span> {</span>
<span id="cb1111-4"><a href="ch_async-js.html#cb1111-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (err) {</span>
<span id="cb1111-5"><a href="ch_async-js.html#cb1111-5" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">.</span><span class="fu">fail</span>(err)<span class="op">;</span></span>
<span id="cb1111-6"><a href="ch_async-js.html#cb1111-6" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb1111-7"><a href="ch_async-js.html#cb1111-7" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">.</span><span class="fu">equal</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb1111-8"><a href="ch_async-js.html#cb1111-8" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1111-9"><a href="ch_async-js.html#cb1111-9" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb1111-10"><a href="ch_async-js.html#cb1111-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>When there is an asynchronous function call:</p>
<div class="sourceCode" id="cb1112"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1112-1"><a href="ch_async-js.html#cb1112-1" aria-hidden="true" tabindex="-1"></a><span class="fu">divideCallback</span>(x<span class="op">,</span> y<span class="op">,</span> callback)</span></code></pre></div>
<p>Then the following steps happen:</p>
<ul>
<li><code>divideCallback()</code> sends a request to a server.</li>
<li>Then the current task <code>main()</code> is finished and other tasks can be executed.</li>
<li>When a response from the server arrives, it is either:
<ul>
<li><p>An error <code>err</code>: Then the following task is added to the queue.</p>
<div class="sourceCode" id="cb1113"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1113-1"><a href="ch_async-js.html#cb1113-1" aria-hidden="true" tabindex="-1"></a>taskQueue<span class="op">.</span><span class="fu">enqueue</span>(() <span class="kw">=&gt;</span> <span class="fu">callback</span>(err))<span class="op">;</span></span></code></pre></div></li>
<li><p>A result <code>r</code>: Then the following task is added to the queue.</p>
<div class="sourceCode" id="cb1114"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1114-1"><a href="ch_async-js.html#cb1114-1" aria-hidden="true" tabindex="-1"></a>taskQueue<span class="op">.</span><span class="fu">enqueue</span>(() <span class="kw">=&gt;</span> <span class="fu">callback</span>(<span class="kw">null</span><span class="op">,</span> r))<span class="op">;</span></span></code></pre></div></li>
</ul></li>
</ul>
<h4 id="promise-based-asynchronous-functions">39.1.4 Promise-based asynchronous functions</h4>
<p>Promises are two things:</p>
<ul>
<li>A standard pattern that makes working with callbacks easier.</li>
<li>The mechanism on which <em>async functions</em> (the topic of <span data-refcheck="#roadmap-async-functions">the next subsection</span>) are built.</li>
</ul>
<p>Invoking a Promise-based function looks as follows.</p>
<div class="sourceCode" id="cb1115"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1115-1"><a href="ch_async-js.html#cb1115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb1115-2"><a href="ch_async-js.html#cb1115-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dividePromise</span>(<span class="dv">12</span><span class="op">,</span> <span class="dv">3</span>)</span>
<span id="cb1115-3"><a href="ch_async-js.html#cb1115-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> assert<span class="op">.</span><span class="fu">equal</span>(result<span class="op">,</span> <span class="dv">4</span>))</span>
<span id="cb1115-4"><a href="ch_async-js.html#cb1115-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">catch</span>(err <span class="kw">=&gt;</span> assert<span class="op">.</span><span class="fu">fail</span>(err))<span class="op">;</span></span>
<span id="cb1115-5"><a href="ch_async-js.html#cb1115-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h4 id="roadmap-async-functions">39.1.5 Async functions</h4>
<p>One way of looking at async functions is as better syntax for Promise-based code:</p>
<div class="sourceCode" id="cb1116"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1116-1"><a href="ch_async-js.html#cb1116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb1116-2"><a href="ch_async-js.html#cb1116-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb1116-3"><a href="ch_async-js.html#cb1116-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> result <span class="op">=</span> <span class="cf">await</span> <span class="fu">dividePromise</span>(<span class="dv">12</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1116-4"><a href="ch_async-js.html#cb1116-4" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb1116-5"><a href="ch_async-js.html#cb1116-5" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (err) {</span>
<span id="cb1116-6"><a href="ch_async-js.html#cb1116-6" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">fail</span>(err)<span class="op">;</span></span>
<span id="cb1116-7"><a href="ch_async-js.html#cb1116-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1116-8"><a href="ch_async-js.html#cb1116-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>dividePromise()</code> we are calling in line A is the same Promise-based function as in the previous section. But we now have synchronous-looking syntax for handling the call. <code>await</code> can only be used inside a special kind of function, an <em>async function</em> (note the keyword <code>async</code> in front of the keyword <code>function</code>). <code>await</code> pauses the current async function and returns from it. Once the awaited result is ready, the execution of the function continues where it left off.</p>
<h4 id="next-steps">39.1.6 Next steps</h4>
<ul>
<li>In this chapter, we’ll see how synchronous function calls work. We’ll also explore JavaScript’s way of executing code in a single process, via its <em>event loop</em>.</li>
<li><a href="ch_async-js.html#callback-pattern">Asynchronicity via callbacks</a> is also described in this chapter.</li>
<li>The following chapters cover <a href="ch_promises.html">Promises</a> and <a href="ch_async-functions.html">async functions</a>.</li>
<li>This series of chapters on asynchronous programming concludes with <a href="ch_async-iteration.html">the chapter on asynchronous iteration</a>, which is similar to <a href="ch_sync-iteration.html">synchronous iteration</a>, but iterated values are delivered asynchronously.</li>
</ul>
<h3 id="the-call-stack">39.2 The call stack</h3>
<p><a id="index-entry-448" class="index-entry"></a></p>
<p>Whenever a function calls another function, we need to remember where to return to after the latter function is finished. That is typically done via a stack – the <em>call stack</em>: the caller pushes onto it the location to return to, and the callee jumps to that location after it is done.</p>
<p>This is an example where several calls happen:</p>
<div class="sourceCode" id="cb1117"><pre class="sourceCode numberSource js numberLines"><code class="sourceCode javascript"><span id="cb1117-1"><a href="ch_async-js.html#cb1117-1"></a><span class="kw">function</span> <span class="fu">h</span>(z) {</span>
<span id="cb1117-2"><a href="ch_async-js.html#cb1117-2"></a>  <span class="kw">const</span> error <span class="op">=</span> <span class="kw">new</span> <span class="bu">Error</span>()<span class="op">;</span></span>
<span id="cb1117-3"><a href="ch_async-js.html#cb1117-3"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(error<span class="op">.</span><span class="at">stack</span>)<span class="op">;</span></span>
<span id="cb1117-4"><a href="ch_async-js.html#cb1117-4"></a>}</span>
<span id="cb1117-5"><a href="ch_async-js.html#cb1117-5"></a><span class="kw">function</span> <span class="fu">g</span>(y) {</span>
<span id="cb1117-6"><a href="ch_async-js.html#cb1117-6"></a>  <span class="fu">h</span>(y <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1117-7"><a href="ch_async-js.html#cb1117-7"></a>}</span>
<span id="cb1117-8"><a href="ch_async-js.html#cb1117-8"></a><span class="kw">function</span> <span class="fu">f</span>(x) {</span>
<span id="cb1117-9"><a href="ch_async-js.html#cb1117-9"></a>  <span class="fu">g</span>(x <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1117-10"><a href="ch_async-js.html#cb1117-10"></a>}</span>
<span id="cb1117-11"><a href="ch_async-js.html#cb1117-11"></a><span class="fu">f</span>(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb1117-12"><a href="ch_async-js.html#cb1117-12"></a><span class="co">// done</span></span></code></pre></div>
<p>Initially, before running this piece of code, the call stack is empty. After the function call <code>f(3)</code> in line 11, the stack has one entry:</p>
<ul>
<li>Line 12 (location in top-level scope)</li>
</ul>
<p>After the function call <code>g(x + 1)</code> in line 9, the stack has two entries:</p>
<ul>
<li>Line 10 (location in <code>f()</code>)</li>
<li>Line 12 (location in top-level scope)</li>
</ul>
<p>After the function call <code>h(y + 1)</code> in line 6, the stack has three entries:</p>
<ul>
<li>Line 7 (location in <code>g()</code>)</li>
<li>Line 10 (location in <code>f()</code>)</li>
<li>Line 12 (location in top-level scope)</li>
</ul>
<p>Logging <code>error</code> in line 3, produces the following output:</p>
<div class="sourceCode" id="cb1118"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1118-1"><a href="ch_async-js.html#cb1118-1" aria-hidden="true" tabindex="-1"></a>DEBUG</span></code></pre></div>
<pre class="text"><code>Error: 
    at h (file://demos/async-js/stack_trace.mjs:2:17)
    at g (file://demos/async-js/stack_trace.mjs:6:3)
    at f (file://demos/async-js/stack_trace.mjs:9:3)
    at file://demos/async-js/stack_trace.mjs:11:1</code></pre>
<p>This is a so-called <em>stack trace</em> of where the <code>Error</code> object was created. Note that it records where calls were made, not return locations. Creating the exception in line 2 is yet another call. That’s why the stack trace includes a location inside <code>h()</code>.</p>
<p>After line 3, each of the functions terminates and each time, the top entry is removed from the call stack. After function <code>f</code> is done, we are back in top-level scope and the stack is empty. When the code fragment ends then that is like an implicit <code>return</code>. If we consider the code fragment to be a task that is executed, then returning with an empty call stack ends the task.</p>
<h3 id="the-event-loop">39.3 The event loop</h3>
<p><a id="index-entry-449" class="index-entry"></a><a id="index-entry-450" class="index-entry"></a></p>
<p>By default, JavaScript runs in a single process – in both web browsers and Node.js. The so-called <em>event loop</em> sequentially executes <em>tasks</em> (pieces of code) inside that process. The event loop is depicted in fig.&nbsp;<a href="#fig:event_loop">21</a>.</p>
<figure>
<img src="img-book/5ff3ceec8864686095e9580568899744400e5b00.svg" id="fig:event_loop" width="363" height="260" alt="Figure 21: Task sources add code to run to the task queue, which is emptied by the event loop."><figcaption aria-hidden="true">Figure 21: <em>Task sources</em> add code to run to the <em>task queue</em>, which is emptied by the <em>event loop</em>.</figcaption>
</figure>
<p>Two parties access the task queue:</p>
<ul>
<li><p><em>Task sources</em> add tasks to the queue. Some of those sources run concurrently to the JavaScript process. For example, one task source takes care of user interface events: if a user clicks somewhere and a click listener was registered, then an invocation of that listener is added to the task queue.</p></li>
<li><p>The <em>event loop</em> runs continuously inside the JavaScript process. During each loop iteration, it takes one task out of the queue (if the queue is empty, it waits until it isn’t) and executes it. That task is finished when the call stack is empty and there is a <code>return</code>. Control goes back to the event loop, which then retrieves the next task from the queue and executes it. And so on.</p></li>
</ul>
<p>The following JavaScript code is an approximation of the event loop:</p>
<div class="sourceCode" id="cb1120"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1120-1"><a href="ch_async-js.html#cb1120-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb1120-2"><a href="ch_async-js.html#cb1120-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> task <span class="op">=</span> taskQueue<span class="op">.</span><span class="fu">dequeue</span>()<span class="op">;</span></span>
<span id="cb1120-3"><a href="ch_async-js.html#cb1120-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">task</span>()<span class="op">;</span> <span class="co">// run task</span></span>
<span id="cb1120-4"><a href="ch_async-js.html#cb1120-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h3 id="how-to-avoid-blocking-the-javascript-process">39.4 How to avoid blocking the JavaScript process</h3>
<h4 id="blocking-browsers">39.4.1 The user interface of the browser can be blocked</h4>
<p>Many of the user interface mechanisms of browsers also run in the JavaScript process (as tasks). Therefore, long-running JavaScript code can block the user interface. Let’s look at a web page that demonstrates that. There are two ways in which you can try out that page:</p>
<ul>
<li>You can <a href="http://rauschma.github.io/async-examples/blocking.html">run it online</a>.</li>
<li>You can open the following file inside the repository with the exercises: <code>demos/async-js/blocking.html</code></li>
</ul>
<p>The following HTML is the page’s user interface:</p>
<div class="sourceCode" id="cb1121"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb1121-1"><a href="ch_async-js.html#cb1121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;a</span><span class="ot"> id=</span><span class="st">"block"</span><span class="ot"> href=</span><span class="st">""</span><span class="kw">&gt;</span>Block<span class="kw">&lt;/a&gt;</span></span>
<span id="cb1121-2"><a href="ch_async-js.html#cb1121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">"statusMessage"</span><span class="kw">&gt;&lt;/div&gt;</span></span>
<span id="cb1121-3"><a href="ch_async-js.html#cb1121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;button&gt;</span>Click me!<span class="kw">&lt;/button&gt;</span></span></code></pre></div>
<p>The idea is that you click “Block” and a long-running loop is executed via JavaScript. During that loop, you can’t click the button because the browser/JavaScript process is blocked.</p>
<p>A simplified version of the JavaScript code looks like this:</p>
<div class="sourceCode" id="cb1122"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1122-1"><a href="ch_async-js.html#cb1122-1" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">getElementById</span>(<span class="st">'block'</span>)</span>
<span id="cb1122-2"><a href="ch_async-js.html#cb1122-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">'click'</span><span class="op">,</span> doBlock)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1122-3"><a href="ch_async-js.html#cb1122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1122-4"><a href="ch_async-js.html#cb1122-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">doBlock</span>(<span class="bu">event</span>) {</span>
<span id="cb1122-5"><a href="ch_async-js.html#cb1122-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ···</span></span>
<span id="cb1122-6"><a href="ch_async-js.html#cb1122-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">displayStatus</span>(<span class="st">'Blocking...'</span>)<span class="op">;</span></span>
<span id="cb1122-7"><a href="ch_async-js.html#cb1122-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ···</span></span>
<span id="cb1122-8"><a href="ch_async-js.html#cb1122-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sleep</span>(<span class="dv">5000</span>)<span class="op">;</span> <span class="co">// (B)</span></span>
<span id="cb1122-9"><a href="ch_async-js.html#cb1122-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">displayStatus</span>(<span class="st">'Done'</span>)<span class="op">;</span></span>
<span id="cb1122-10"><a href="ch_async-js.html#cb1122-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1122-11"><a href="ch_async-js.html#cb1122-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1122-12"><a href="ch_async-js.html#cb1122-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">sleep</span>(milliseconds) {</span>
<span id="cb1122-13"><a href="ch_async-js.html#cb1122-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> start <span class="op">=</span> <span class="bu">Date</span><span class="op">.</span><span class="fu">now</span>()<span class="op">;</span></span>
<span id="cb1122-14"><a href="ch_async-js.html#cb1122-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> ((<span class="bu">Date</span><span class="op">.</span><span class="fu">now</span>() <span class="op">-</span> start) <span class="op">&lt;</span> milliseconds)<span class="op">;</span></span>
<span id="cb1122-15"><a href="ch_async-js.html#cb1122-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1122-16"><a href="ch_async-js.html#cb1122-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">displayStatus</span>(status) {</span>
<span id="cb1122-17"><a href="ch_async-js.html#cb1122-17" aria-hidden="true" tabindex="-1"></a>  <span class="bu">document</span><span class="op">.</span><span class="fu">getElementById</span>(<span class="st">'statusMessage'</span>)</span>
<span id="cb1122-18"><a href="ch_async-js.html#cb1122-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> status<span class="op">;</span></span>
<span id="cb1122-19"><a href="ch_async-js.html#cb1122-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These are the key parts of the code:</p>
<ul>
<li>Line A: We tell the browser to call <code>doBlock()</code> whenever the HTML element is clicked whose ID is <code>block</code>.</li>
<li><code>doBlock()</code> displays status information and then calls <code>sleep()</code> to block the JavaScript process for 5000 milliseconds (line B).</li>
<li><code>sleep()</code> blocks the JavaScript process by looping until enough time has passed.</li>
<li><code>displayStatus()</code> displays status messages inside the <code>&lt;div&gt;</code> whose ID is <code>statusMessage</code>.</li>
</ul>
<h4 id="web-workers">39.4.2 How can we avoid blocking the browser?</h4>
<p><a id="index-entry-451" class="index-entry"></a></p>
<p>There are several ways in which you can prevent a long-running operation from blocking the browser:</p>
<ul>
<li><p>The operation can deliver its result <em>asynchronously</em>: Some operations, such as downloads, can be performed concurrently to the JavaScript process. The JavaScript code triggering such an operation registers a callback, which is invoked with the result once the operation is finished. The invocation is handled via the task queue. This style of delivering a result is called <em>asynchronous</em> because the caller doesn’t wait until the results are ready. Normal function calls deliver their results synchronously.</p></li>
<li><p>Perform long computations in separate processes: This can be done via so-called <em>Web Workers</em>. Web Workers are heavyweight processes that run concurrently to the main process. Each one of them has its own runtime environment (global variables, etc.). They are completely isolated and must be communicated with via message passing. Consult <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">MDN web docs</a> for more information.</p></li>
<li><p>Take breaks during long computations. <span data-refcheck="#taking-breaks">The next subsection</span> explains how.</p></li>
</ul>
<h4 id="taking-breaks">39.4.3 Taking breaks</h4>
<p>The following global function executes its parameter <code>callback</code> after a delay of <code>ms</code> milliseconds (the type signature is simplified – <code>setTimeout()</code> has more features):</p>
<div class="sourceCode" id="cb1123"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb1123-1"><a href="ch_async-js.html#cb1123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">setTimeout</span>(callback<span class="op">:</span> () <span class="kw">=&gt;</span> <span class="dt">void</span><span class="op">,</span> ms<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">any</span></span></code></pre></div>
<p>The function returns a <em>handle</em> (an ID) that can be used to <em>clear</em> the timeout (cancel the execution of the callback) via the following global function:</p>
<div class="sourceCode" id="cb1124"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb1124-1"><a href="ch_async-js.html#cb1124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">clearTimeout</span>(handle<span class="op">?:</span> <span class="dt">any</span>)<span class="op">:</span> <span class="dt">void</span></span></code></pre></div>
<p><code>setTimeout()</code> is available on both browsers and Node.js. <span data-refcheck="#run-to-completion-semantics">The next subsection</span> shows it in action.</p>
<div class="notebox">
<p><img src="img-book/img/icons/lightbulb-regular.svg" height="24">&nbsp; <strong><code>setTimeout()</code> lets tasks take breaks</strong></p>
<p>Another way of looking at <code>setTimeout()</code> is that the current task takes a break and continues later via the callback.</p>
</div>
<h4 id="run-to-completion-semantics">39.4.4 Run-to-completion semantics</h4>
<p><a id="index-entry-452" class="index-entry"></a></p>
<p>JavaScript makes a guarantee for tasks:</p>
<blockquote>
<p>Each task is always finished (“run to completion”) before the next task is executed.</p>
</blockquote>
<p>As a consequence, tasks don’t have to worry about their data being changed while they are working on it (<em>concurrent modification</em>). That simplifies programming in JavaScript.</p>
<p>The following example demonstrates this guarantee:</p>
<div class="sourceCode" id="cb1125"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1125-1"><a href="ch_async-js.html#cb1125-1" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">'start'</span>)<span class="op">;</span></span>
<span id="cb1125-2"><a href="ch_async-js.html#cb1125-2" aria-hidden="true" tabindex="-1"></a><span class="pp">setTimeout</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb1125-3"><a href="ch_async-js.html#cb1125-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">'callback'</span>)<span class="op">;</span></span>
<span id="cb1125-4"><a href="ch_async-js.html#cb1125-4" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb1125-5"><a href="ch_async-js.html#cb1125-5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">'end'</span>)<span class="op">;</span></span>
<span id="cb1125-6"><a href="ch_async-js.html#cb1125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1125-7"><a href="ch_async-js.html#cb1125-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Output:</span></span>
<span id="cb1125-8"><a href="ch_async-js.html#cb1125-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 'start'</span></span>
<span id="cb1125-9"><a href="ch_async-js.html#cb1125-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 'end'</span></span>
<span id="cb1125-10"><a href="ch_async-js.html#cb1125-10" aria-hidden="true" tabindex="-1"></a><span class="co">// 'callback'</span></span></code></pre></div>
<p><code>setTimeout()</code> puts its parameter into the task queue. The parameter is therefore executed sometime after the current piece of code (task) is completely finished.</p>
<p>The parameter <code>ms</code> only specifies when the task is put into the queue, not when exactly it runs. It may even never run – for example, if there is a task before it in the queue that never terminates. That explains why the previous code logs <code>'end'</code> before <code>'callback'</code>, even though the parameter <code>ms</code> is <code>0</code>.</p>
<h3 id="patterns-for-delivering-asynchronous-results">39.5 Patterns for delivering asynchronous results</h3>
<p>In order to avoid blocking the main process while waiting for a long-running operation to finish, results are often delivered asynchronously in JavaScript. These are three popular patterns for doing so:</p>
<ul>
<li>Events</li>
<li>Callbacks</li>
<li>Promises</li>
</ul>
<p>The first two patterns are explained in <span data-refcheck="#event-pattern #callback-pattern">the next two subsections</span>. Promises are explained in <a href="ch_promises.html">the next chapter</a>.</p>
<h4 id="event-pattern">39.5.1 Delivering asynchronous results via events</h4>
<p><a id="index-entry-453" class="index-entry"></a></p>
<p>Events as a pattern work as follows:</p>
<ul>
<li>They are used to deliver values asynchronously.</li>
<li>They do so zero or more times.</li>
<li>There are three roles in this pattern:
<ul>
<li>The <em>event</em> (an object) carries the data to be delivered.</li>
<li>The <em>event listener</em> is a function that receives events via a parameter.</li>
<li>The <em>event source</em> sends events and lets you register event listeners.</li>
</ul></li>
</ul>
<p>Multiple variations of this pattern exist in the world of JavaScript. We’ll look at three examples next.</p>
<h5 id="events-indexeddb">39.5.1.1 Events: IndexedDB</h5>
<p>IndexedDB is a database that is built into web browsers. This is an example of using it:</p>
<div class="sourceCode" id="cb1126"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1126-1"><a href="ch_async-js.html#cb1126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> openRequest <span class="op">=</span> indexedDB<span class="op">.</span><span class="fu">open</span>(<span class="st">'MyDatabase'</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1126-2"><a href="ch_async-js.html#cb1126-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1126-3"><a href="ch_async-js.html#cb1126-3" aria-hidden="true" tabindex="-1"></a>openRequest<span class="op">.</span><span class="at">onsuccess</span> <span class="op">=</span> (<span class="bu">event</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb1126-4"><a href="ch_async-js.html#cb1126-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> db <span class="op">=</span> <span class="bu">event</span><span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">result</span><span class="op">;</span></span>
<span id="cb1126-5"><a href="ch_async-js.html#cb1126-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ···</span></span>
<span id="cb1126-6"><a href="ch_async-js.html#cb1126-6" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb1126-7"><a href="ch_async-js.html#cb1126-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1126-8"><a href="ch_async-js.html#cb1126-8" aria-hidden="true" tabindex="-1"></a>openRequest<span class="op">.</span><span class="at">onerror</span> <span class="op">=</span> (error) <span class="kw">=&gt;</span> {</span>
<span id="cb1126-9"><a href="ch_async-js.html#cb1126-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error)<span class="op">;</span></span>
<span id="cb1126-10"><a href="ch_async-js.html#cb1126-10" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p><code>indexedDB</code> has an unusual way of invoking operations:</p>
<ul>
<li><p>Each operation has an associated method for creating <em>request objects</em>. For example, in line A, the operation is “open”, the method is <code>.open()</code>, and the request object is <code>openRequest</code>.</p></li>
<li><p>The parameters for the operation are provided via the request object, not via parameters of the method. For example, the event listeners (functions) are stored in the properties <code>.onsuccess</code> and <code>.onerror</code>.</p></li>
<li><p>The invocation of the operation is added to the task queue via the method (in line A). That is, we configure the operation <em>after</em> its invocation has already been added to the queue. Only run-to-completion semantics saves us from race conditions here and ensures that the operation runs after the current code fragment is finished.</p></li>
</ul>
<h5 id="XMLHttpRequest">39.5.1.2 Events: <code>XMLHttpRequest</code></h5>
<p>The <code>XMLHttpRequest</code> API lets us make downloads from within a web browser. This is how we download the file <code>http://example.com/textfile.txt</code>:</p>
<div class="sourceCode" id="cb1127"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1127-1"><a href="ch_async-js.html#cb1127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1127-2"><a href="ch_async-js.html#cb1127-2" aria-hidden="true" tabindex="-1"></a>xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">'GET'</span><span class="op">,</span> <span class="st">'http://example.com/textfile.txt'</span>)<span class="op">;</span> <span class="co">// (B)</span></span>
<span id="cb1127-3"><a href="ch_async-js.html#cb1127-3" aria-hidden="true" tabindex="-1"></a>xhr<span class="op">.</span><span class="at">onload</span> <span class="op">=</span> () <span class="kw">=&gt;</span> { <span class="co">// (C)</span></span>
<span id="cb1127-4"><a href="ch_async-js.html#cb1127-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (xhr<span class="op">.</span><span class="at">status</span> <span class="op">==</span> <span class="dv">200</span>) {</span>
<span id="cb1127-5"><a href="ch_async-js.html#cb1127-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">processData</span>(xhr<span class="op">.</span><span class="at">responseText</span>)<span class="op">;</span></span>
<span id="cb1127-6"><a href="ch_async-js.html#cb1127-6" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb1127-7"><a href="ch_async-js.html#cb1127-7" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">fail</span>(<span class="kw">new</span> <span class="bu">Error</span>(xhr<span class="op">.</span><span class="at">statusText</span>))<span class="op">;</span></span>
<span id="cb1127-8"><a href="ch_async-js.html#cb1127-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1127-9"><a href="ch_async-js.html#cb1127-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb1127-10"><a href="ch_async-js.html#cb1127-10" aria-hidden="true" tabindex="-1"></a>xhr<span class="op">.</span><span class="at">onerror</span> <span class="op">=</span> () <span class="kw">=&gt;</span> { <span class="co">// (D)</span></span>
<span id="cb1127-11"><a href="ch_async-js.html#cb1127-11" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">fail</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Network error'</span>))<span class="op">;</span></span>
<span id="cb1127-12"><a href="ch_async-js.html#cb1127-12" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb1127-13"><a href="ch_async-js.html#cb1127-13" aria-hidden="true" tabindex="-1"></a>xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span> <span class="co">// (E)</span></span>
<span id="cb1127-14"><a href="ch_async-js.html#cb1127-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1127-15"><a href="ch_async-js.html#cb1127-15" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">processData</span>(str) {</span>
<span id="cb1127-16"><a href="ch_async-js.html#cb1127-16" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">equal</span>(str<span class="op">,</span> <span class="st">'Content of textfile.txt</span><span class="sc">\n</span><span class="st">'</span>)<span class="op">;</span></span>
<span id="cb1127-17"><a href="ch_async-js.html#cb1127-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>With this API, we first create a request object (line A), then configure it, then activate it (line E). The configuration consists of:</p>
<ul>
<li>Specifying which HTTP request method to use (line B): <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc.</li>
<li>Registering a listener (line C) that is notified if something could be downloaded. Inside the listener, we still need to determine if the download contains what we requested or informs us of an error. Note that some of the result data is delivered via the request object <code>xhr</code>. (I’m not a fan of this kind of mixing of input and output data.)</li>
<li>Registering a listener (line D) that is notified if there was a network error.</li>
</ul>
<h5 id="events-dom">39.5.1.3 Events: DOM</h5>
<p>We have already seen DOM events in action in <a href="ch_async-js.html#blocking-browsers">§39.4.1 “The user interface of the browser can be blocked”</a>. The following code also handles <code>click</code> events:</p>
<div class="sourceCode" id="cb1128"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1128-1"><a href="ch_async-js.html#cb1128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> element <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">getElementById</span>(<span class="st">'my-link'</span>)<span class="op">;</span> <span class="co">// (A)</span></span>
<span id="cb1128-2"><a href="ch_async-js.html#cb1128-2" aria-hidden="true" tabindex="-1"></a>element<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">'click'</span><span class="op">,</span> clickListener)<span class="op">;</span> <span class="co">// (B)</span></span>
<span id="cb1128-3"><a href="ch_async-js.html#cb1128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1128-4"><a href="ch_async-js.html#cb1128-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">clickListener</span>(<span class="bu">event</span>) {</span>
<span id="cb1128-5"><a href="ch_async-js.html#cb1128-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">event</span><span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span> <span class="co">// (C)</span></span>
<span id="cb1128-6"><a href="ch_async-js.html#cb1128-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">event</span><span class="op">.</span><span class="at">shiftKey</span>)<span class="op">;</span> <span class="co">// (D)</span></span>
<span id="cb1128-7"><a href="ch_async-js.html#cb1128-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We first ask the browser to retrieve the HTML element whose ID is <code>'my-link'</code> (line A). Then we add a listener for all <code>click</code> events (line B). In the listener, we first tell the browser not to perform its default action (line C) – going to the target of the link. Then we log to the console if the shift key is currently pressed (line D).</p>
<h4 id="callback-pattern">39.5.2 Delivering asynchronous results via callbacks</h4>
<p><a id="index-entry-454" class="index-entry"></a></p>
<p>Callbacks are another pattern for handling asynchronous results. They are only used for one-off results and have the advantage of being less verbose than events.</p>
<p>As an example, consider a function <code>readFile()</code> that reads a text file and returns its contents asynchronously. This is how you call <code>readFile()</code> if it uses Node.js-style callbacks:</p>
<div class="sourceCode" id="cb1129"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1129-1"><a href="ch_async-js.html#cb1129-1" aria-hidden="true" tabindex="-1"></a><span class="fu">readFile</span>(<span class="st">'some-file.txt'</span><span class="op">,</span> {<span class="dt">encoding</span><span class="op">:</span> <span class="st">'utf8'</span>}<span class="op">,</span></span>
<span id="cb1129-2"><a href="ch_async-js.html#cb1129-2" aria-hidden="true" tabindex="-1"></a>  (error<span class="op">,</span> data) <span class="kw">=&gt;</span> {</span>
<span id="cb1129-3"><a href="ch_async-js.html#cb1129-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (error) {</span>
<span id="cb1129-4"><a href="ch_async-js.html#cb1129-4" aria-hidden="true" tabindex="-1"></a>      assert<span class="op">.</span><span class="fu">fail</span>(error)<span class="op">;</span></span>
<span id="cb1129-5"><a href="ch_async-js.html#cb1129-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1129-6"><a href="ch_async-js.html#cb1129-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1129-7"><a href="ch_async-js.html#cb1129-7" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">.</span><span class="fu">equal</span>(data<span class="op">,</span> <span class="st">'The content of some-file.txt</span><span class="sc">\n</span><span class="st">'</span>)<span class="op">;</span></span>
<span id="cb1129-8"><a href="ch_async-js.html#cb1129-8" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<p>There is a single callback that handles both success and failure. If the first parameter is not <code>null</code> then an error happened. Otherwise, the result can be found in the second parameter.</p>
<div class="notebox">
<p><img src="img-book/img/icons/puzzle-piece-regular.svg" height="24">&nbsp; <strong>Exercises: Callback-based code</strong></p>
<p>The following exercises use tests for asynchronous code, which are different from tests for synchronous code. Consult <a href="ch_quizzes-exercises.html#async-tests-mocha">§10.3.2 “Asynchronous tests in Mocha”</a> for more information.</p>
<ul>
<li>From synchronous to callback-based code: <code>exercises/async-js/read_file_cb_exrc.mjs</code></li>
<li>Implementing a callback-based version of <code>.map()</code>: <code>exercises/async-js/map_cb_test.mjs</code></li>
</ul>
</div>
<h3 id="asynchronous-code-the-downsides">39.6 Asynchronous code: the downsides</h3>
<p>In many situations, on either browsers or Node.js, you have no choice, you must use asynchronous code. In this chapter, we have seen several patterns that such code can use. All of them have two disadvantages:</p>
<ul>
<li>Asynchronous code is more verbose than synchronous code.</li>
<li>If you call asynchronous code, your code must become asynchronous too. That’s because you can’t wait synchronously for an asynchronous result. Asynchronous code has an infectious quality.</li>
</ul>
<p>The first disadvantage becomes less severe with Promises (covered in <a href="ch_promises.html">the next chapter</a>) and mostly disappears with async functions (covered in <a href="ch_async-functions.html">the chapter after next</a>).</p>
<p>Alas, the infectiousness of async code does not go away. But it is mitigated by the fact that switching between sync and async is easy with async functions.</p>
<h3 id="resources">39.7 Resources</h3>
<ul>
<li><a href="https://vimeo.com/96425312">“Help, I’m stuck in an event-loop”</a> by Philip Roberts (video).</li>
<li><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops">“Event loops”</a>, section in HTML5 spec.</li>
</ul>

    <div class="footer">
      <div>
                <a id="commentLink" href="https://github.com/rauschma/impatient-js/issues/26">Comments</a>
        <script defer="" src="count-comments.js"></script>
              </div>
            <div>
        Next: <a href="ch_promises.html">40 Promises for asynchronous programming [ES6]</a>
      </div>
          </div>
  
    </body>
    </html>
    